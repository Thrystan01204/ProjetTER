\documentclass[a4paper]{report}
\usepackage{a4wide}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage[babel=true]{csquotes} % guillemets français
\usepackage{graphicx}
\usepackage{float}

\author{SALVAN Corentin - MEHONG-SHIT-LI Matthieu - MARTINEZ Damien \\ BAIRY ONAPA Mikaël - LE LIDEC Tristan}
\title{\underline{Rapport Projet TER : Conception d'une surveillance vidéo médicale}}

\begin{document}
    \maketitle
    
    \tableofcontents
    
    \chapter{Avant propos}

    L'objectif de cette unité d'enseignement est de nous préparé aux projets d'études de Master.
    Non content de consolider notre bagage scientifique, nous collaborons parmi un groupe de projet
    afin de sortir un produit fini, contexte qui pourrait se retrouver dans le milieu professionnelle
    également.
    Nous tenons avant tout à remercier Mr LAN SUN LUK Jean-Daniel pour l'aide précieuse apportée
    lors des points de blocages. Ce projet n'aurait pas aboutis dans le temps si nous n'avions consulter
    ouvrages et documents en ligne, sur lequel nous avons pu tirer informations, codes et librairies.
    Nous remerçions donc ces écrivains parfois anonymes.
    
    \chapter{Introduction}
    \chapter{Description}
        \section{Définition du projet}
    Le but de ce projet est de réaliser une surveillance vidéo avec deux composantes, la détection de chute et la reconnaissance faciale.
    Pour la détection de chute, lorsqu'une chute sera détecté une alarme sera activé afin d'alerter le personnel soignant. Depuis une interface graphique l'utilisateur pourra visualiser en temps réel le flux vidéo, choisir la caméra, mettre en pause le flux vidéo et désactiver l'alarme. Concernant la reconnaissance faciale, l'utilisateur connaitra le nom et le prénom de la personne si il est enregistré dans la base de données de l'établissement, ce qui permettra de détecter les éventuels intrus.
        \section{Cahier des charges}
        
        \section{Support Logiciels/ Langage de Programmation/ Librairie}
        
        Plusieurs langages de programmation ont été discuté avant la réalisation du projet, dans un premier temps, nous avons opté pour le langage JAVA, notamment pour la programmation orienté objet qui facilite le travail en équipe lors du dévellopement. Finalement nous nous sommes decidé pour le langage Python, car il bénéfie d'une grande communauté, possède de nombreuses librairies, fonctionnalités que nous avions besoin. D'autre part c'est un langage que tous les membres de l'équipe savaient déjà programmer en Python.
        On utilise Virtual Box comme logiciel de simulation de différents systèmes d'exploitations.
    A partir des ressources d'une machine h\^{o}te ayant des performances correctes, dans notre 
    cas un Window 10, nous créons deux machines virtuelles de types Linux (Debian et Raspberry OS).
    La démarche vise avant tout à régler les configurations, installer logiciels et libraires utiles et 
    tester le code. Nous en parlerons dans la prochaine section.

    Nous établissons une connexion SSH entre le Raspberry Pi (serveur) et notre PC Window (client) dû au fait
    que nous avions pas de moniteur de contr\^{o}le. Le protoc\^{o}le SSH est un moyen 
    de communication sécurisé et chiffré sur un réseau. (Une équivalence plus simple
    existe, le protoc\^{o}le Telnet, mais il transfère les données de façon trop visible
    sur le réseau et est donc sensible au piratage). (Bibliothèque \ref{bib:Connexion SSH},
    p\pageref{bib:Connexion SSH}) 

    Nous réalisons le schéma électrique de la section \ref{sec:schema montage} avec le logiciel KiCad,
    qui est un logiciel multi-plaforme pouvant dessiner un schéma électronique, créer une empreinte
    PCB pour la réalisation de circuits imprimés ou faire une modélisation 3D du circuit.
    
    

    \chapter{Modélisation}
        \section{Machine virtuelle OS Linux(Debian)}
        \section{Machine virtuelle OS Raspberry Pi 2}
        
        
        \section{Schéma de montage Hardware et description des composants}  \label{sec:schema montage}

    Sur la partie matériel nous avons choisi d'utiliser un Rasberry Pi, du fait de son aspect compact et 
    de sa grande capacité de calcul. Le modèle utilisé est le Raspberry 3b+, on énumère ici quelques
    caractéristiques:
        \begin{itemize}
            \item Mémoire vive :1 GB, 1.2GHz Quad-Core ARM Cortex-A53
            \item Nombre de coeur : 4
            \item Alimentation : 5V, 2A
            \item Ports USB : 4
            \item Module Bluetooth 4.1 et Wifi
            \item Interface Carte Graphique : PCI-E
            \item Processeur : 4 x ARM(v7) 7100
            \item GPU : Dual Core VideoCore IV \newline
        \end{itemize}
    On liste ici les ports GPIO de raspberry utile pour la connexion avec le module RFID:\newline
        \begin{tabular}{||p{2cm}||*{8}{c|}|}
            \hline
            \small{RFID} & \small{Vcc +3.3V} & \small{GND} & \small{MISO} 
            & \small{MOSI} & \small{SCK} & \small{SDA} & \small{RST} \\
            \hline
            \bfseries \small{Raspberry} & \small{01-3.3V} & \small{06-Ground} 
            & \small{21-GPIO09} & \small{19-GPIO10} & \small{23-GPIO11} 
            & \small{24-GPIO08} & \small{22-GPIO25} \\
            \hline
            \end{tabular}\newline
            
            
            
    
    \chapter{Réalisation Software-Hardware}
        \section{Acquisition vidéo}
            Grâce à la librairie openCV, nous pouvons faire l'acquisition de tout type de caméra, en effet il suffit que la caméra soit branché à l'ordinateur pour qu'on l'utiliser. La lbrairie prend aussi en charge les caméras IP et le fichier vidéo.
            \\
            A chaque appel de la fonction capture.read(), la librairie capture l'image du flux vidéo en entré, cette image va ensuite être utilisé pour faire les différents traitements et notamment la détection de chute.

        \section{Détection de chute}
            La détection se décompose en deux parties, la première consiste à extraire le sujet de la scène et la deuxième étudier son déplacement afin de savoir si oui ou non il y a bien eu une chute.
            \subsection{Extraction du sujet}
            Pour extraire le sujet deux méthodes ont été etudiés, la première methode consiste à utiliser une technique de classification. c'est une technique d'apprentissage supervisé. Il faut d'abord créer une base de données afin d'entrainer le modèle pour pouvoir reconnaitre le pattern souhaité. Cette méthode est coûteuse en ressource, mais peut être très efficace si la base de données est grande. Nous avons
            \subsection{Critère de détection de chute}
        \section{Reconnaissance faciale}
        \section{Interface Graphique}
            Nous avons cherché à créer une interface graphique pour notre porjet qui permette de modifier certains paramètres, de changer la caméra.\\
            Pour réaliser cette interface nous avons utilisé la librairie intégrée de Python, Tkinter. Cette librairie permet de créer des interfaces graphiques assez simplement. Nous pouvons y ajouter des boutons des canvas (rectangle dans lequel nous pouvons placer du contenu).\\
            La première chose que nous avons cherché à réaliser est l'intégration de l'acquisition vidéo à notre interface. 
            \subsection{Intégration de l'acquisition vidéo}
            Pour intégrer l'acquisition vidéo à notre interface, nous devions faire en sorte qu'elle puisse être raffraichie pour modifier l'image affichée. La première idée que nous avons eu consistait à créer deux objets différents, un objet interface qui contiendrait les éléments de l'interface et permettrait d'en créer une. Puis un second objet acquisition, qui devait être l'acquisition vidéo. Nous n'aurions eu alors qu'à raffraichir l'image affichée.\\
            Nous n'avons pas réussi à mettre cette solution en œuvre car l'acquisition vidéo ne possède pas de constructeur qui permette de créer un objet.\\
            La seconde option que nous avons exploré consistait à réaliser un unique code qui contiendrait et l'acquisition vidéo et l'interface.\\
            C'est cettte dernière option qui a été retenue. Elle était plus simple de mise en œuvre. 
        \section{Commande du matériel}

    \chapter{Bilan du projet}

        \section{Difficulté du projet}
        \section{Analyse du résultat confrontée au cahier des charges}
        \section{Piste d'amélioration}
            \subsection{Qualité du matériel}
            \subsection{Résolution du système}
            \subsection{Performance du code et du temps de calcul}
        \section{Timeline (Diagramme de Grantt)}
    
    
    
    
    \clearpage
    \addcontentsline{toc}{chapter}{Bibliographie}
    \begin{thebibliography}{9}

        \bibitem{}
            Ben Nuttall Revision, Edit on GitHub,
            \emph{Librairie : GPIO zero}. \newline
            Consulté le 03/04/2021
            \begin{verbatim}url = https://gpiozero.readthedocs.io/en/stable/index.html   
            \end{verbatim}

        \bibitem{}
            Raspberry Pi FR,
            \emph{Utiliser un lecteur RFID avec Raspberry}. \newline
            Consulté le 03/04/2021
            \begin{verbatim}url = https://raspberry-pi.fr/rfid-raspberry-pi/  
            \end{verbatim}
            
        \bibitem{}\label{bib:Connexion SSH}
            Raspberry Lab fr,
            \emph{Etablir une connexion SSH}. \newline
            Consulté le 17/03/2021
            \begin{verbatim}url = https://raspberry-lab.fr/Debuter-sur-Raspberry-Francais/Connexion-Bureau-a-distance-Raspberry-Francais/#:~:text=Configurations%20sur%20%20Windows%20Text=Entrez%20%20simplement%20%20l'adresse%20IP,pi%20%20et%20%20raspberry)%20%20et%20%20validez.  
            \end{verbatim}

    \end{thebibliography}






    \appendix{}
    \part*{Annexes}
        \section{Code principal du système}
        \section{Code librairie : RFID.py}

\end{document}
